#!/usr/bin/env ruby
OPTS = <<OPTS
  --host      : string          Host to connect to (defaults to "localhost").
  --port      : natural         Port on the host.
  --user      : string          User to connect as (defaults to "guest").
  --pass      : string          Password to use (defaults to "guest").
  --vhost     : string          AMQP virtual host.
  --logging   : bool            Turns on AMQP library's logging (off default).
  --ssl       : bool            Turns on SSL.
OPTS
USAGE = <<USAGE
 USAGE: amqp_in_irb <AMQP URL>
        amqp_in_irb <option>+

  Connect to an AMQP server and pop up an IRB console, using the connection
  parameters provided in an AMQP URL argument, an `AMQP_URL' environment
  variables, RabbitMQ environment variables or options as listed below.

  In the IRB console, there is a variable $conn that exposes the AMQP
  connection. Under the hood, our tool relies on Bunny, a synchronous AMQP
  client library for Ruby. A simple session:

    :;  amqp_in_irb
    Connection available in `$conn'.
    irb(main):001:0> q = $conn.queue('tasks')
    => #<Bunny::Queue:0x7f4982a20d50 @subscripti...
    irb(main):002:0> q.publish('LOL')
    => nil
    irb(main):003:0> m = q.pop[:payload]
    => "LOL"
    irb(main):004:0> q.delete
    => :delete_ok

  Many other AMQP methods are exposed by the Bunny gem.

 OPTIONS

#{OPTS}

USAGE

trap('INT'){ abort 'Terminated.' }


begin
  puts USAGE
  exit 0
end unless (%w| -h -? --help | & ARGV).empty?

require 'irb'

require 'rubygems'
require 'bunny'
require 'mq'


class ParseOneOption
  RE = /^ +(--[^ ]+) +: *(natural|bool|string) +([^ ].+)$/
  def ParseOneOption.parse_option(name, type, array)
    if name == array[0]
      sym = name[2..-1].to_sym
      case type
      when 'string'
        arg = array[1]
        raise "No `#{type}' arg for `#{name}'." unless arg
        [{sym => arg}, array[2..-1]]
      when 'natural'
        arg = array[1]
        raise "No `#{type}' arg for `#{name}'." unless arg
        b = ! /^[0-9]+$/.match(arg).nil?
        raise "Arg `#{arg}' for `#{name}' isn't a natural number." unless b
        [{sym => arg.to_i}, array[2..-1]]
      when 'bool'
        [{sym => true}, array[1..-1]]
      end
    end
  end
  def initialize(s)
    m = RE.match(s)
    raise "Invalid option spec:\n#{s}" unless m
    @name, @type, @desc = m[1..3]
  end
  def parse(array)
    ParseOneOption.parse_option(@name, @type, array)
  end
end

def connect_and_run(params)
  ARGV.clear  # We clear ARGV so IRB won't try to parse our opts.
  begin
    $conn = Bunny.new(params)
    $conn.start
    STDERR.puts "Connection available in `$conn'."
    IRB.start
    $conn.stop
  rescue SystemExit => e
    # Do nothing.
  rescue Exception => e
    STDERR.puts "Exception (#{e.class}):\n  #{e.message}"
  end
end

def opts_from_environment
  results = []
  amqp = ENV['AMQP_URL']
  rabbit_port = ENV['RABBITMQ_NODE_PORT']
  rabbit_ip = ENV['RABBITMQ_NODE_IP_ADDRESS']
  case
  when amqp
    if rabbit_ip or rabbit_port
      STDERR.puts "Ignoring rabbit environment variables due to `AMQP_URL'."
    end
    parts = parse_AMQP_url(amqp)
    if parts.keys.empty?
      STDERR.puts "Unreadable `AMQP_URL'."
    else
      listing = parts.keys.map{|k| "`#{k}'"}.join(', ')
      STDERR.puts "Using `AMQP_URL' to set #{listing}."
      parts.each do |k, v|
        case v
        when TrueClass
          args << k
        else
          results << k << v
        end
      end
    end
  else
    if rabbit_ip
      STDERR.puts "Using `RABBITMQ_NODE_IP_ADDRESS' to set `--host'."
      results << '--host' << rabbit_ip
    end
    if rabbit_port
      STDERR.puts "Using `RABBITMQ_NODE_PORT' to set `--port'."
      results << '--port' << rabbit_port
    end
  end
  results
end

# amqp://root:pwnt@example.com/passwd
AMQP_RE = /^(amqps?):\/\/    ##  AMQP protocol scheme.
             (([^\/:@]+)     ##  User spec. ## User.
              (:([^\/@]+))?                 ## Password.
              @                             ## Closing @ sign.
             )?
             ([^\/:@]+)      ##  Host.
             (:([0-9]+))?    ##  Port.
             (\/([^\/]+))?   ##  Virtual host.
             \/?             ##  Ending slash is ending!
            $/x
def parse_AMQP_url(url)
  result = {}
  m = AMQP_RE.match(url)
  if m
    scheme, _2, user, _4, pass, host, _7, port, _9, vhost = m[1..-1]
    result['--ssl'] = true if 'amqps' == scheme
    result['--user'] = user if user
    result['--pass'] = pass if pass
    result['--host'] = host if host
    result['--port'] = port if port
    result['--vhost'] = vhost if vhost
  end
  result
end

def derive_params
  params = {}
  args = []
  parsers = OPTS.lines.map{|line| ParseOneOption.new(line) }
  case
  when /^amqps?:\/\/[^ ]+$/.match(ARGV.join(' '))
    parts = parse_AMQP_url(ARGV[0])
    abort "Unreadable AMQP URL argument." if parts.keys.empty?
    parts.each do |k, v|
      case v
      when TrueClass
        args << k
      else
        args << k << v
      end
    end
  else
    args = ARGV + opts_from_environment
  end
  while not args.empty?
    res = nil
    parsers.each do |parser|
      begin
        res = parser.parse(args)
      rescue RuntimeError => e
        abort e.message
      end
      if res
        hash, arr = res
        params = params.merge(hash)
        args = arr
        break
      end
    end
    abort "Failing on mysterious argument `#{args[0]}'." unless res
  end
  params
end

#STDERR.puts "Using connection parameters:"
#params.each do |k, v|
#  STDERR.puts sprintf('%-14s  %-40s', "--#{k}", v.to_s)
#end

if __FILE__ == $0
  params = derive_params
  connect_and_run(params)
end

